// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FILE_FILE_H_
#define FLATBUFFERS_GENERATED_FILE_FILE_H_

#include "flatbuffers/flatbuffers.h"

namespace file {

struct Codec;

struct H265Frame;

struct H264Frame;

struct JPEGFrame;

struct MetadataFrame;

struct MPEG4Frame;

struct ObjectDetectorFrame;

struct FrameHeader;

struct Track;

struct Recording;

struct Device;

struct File;

enum class FrameHeaderType : int8_t {
  H264 = 1,
  JPEG = 2,
  METADATA = 3,
  MPEG4 = 4,
  H265 = 5,
  OBJECTDETECTOR = 6,
  MIN = H264,
  MAX = OBJECTDETECTOR
};

inline const FrameHeaderType (&EnumValuesFrameHeaderType())[6] {
  static const FrameHeaderType values[] = {
    FrameHeaderType::H264,
    FrameHeaderType::JPEG,
    FrameHeaderType::METADATA,
    FrameHeaderType::MPEG4,
    FrameHeaderType::H265,
    FrameHeaderType::OBJECTDETECTOR
  };
  return values;
}

inline const char * const *EnumNamesFrameHeaderType() {
  static const char * const names[7] = {
    "H264",
    "JPEG",
    "METADATA",
    "MPEG4",
    "H265",
    "OBJECTDETECTOR",
    nullptr
  };
  return names;
}

inline const char *EnumNameFrameHeaderType(FrameHeaderType e) {
  if (e < FrameHeaderType::H264 || e > FrameHeaderType::OBJECTDETECTOR) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(FrameHeaderType::H264);
  return EnumNamesFrameHeaderType()[index];
}

enum class MetadataFrameType : uint16_t {
  ONVIF_XML = 1,
  MIN = ONVIF_XML,
  MAX = ONVIF_XML
};

inline const MetadataFrameType (&EnumValuesMetadataFrameType())[1] {
  static const MetadataFrameType values[] = {
    MetadataFrameType::ONVIF_XML
  };
  return values;
}

inline const char * const *EnumNamesMetadataFrameType() {
  static const char * const names[2] = {
    "ONVIF_XML",
    nullptr
  };
  return names;
}

inline const char *EnumNameMetadataFrameType(MetadataFrameType e) {
  if (e < MetadataFrameType::ONVIF_XML || e > MetadataFrameType::ONVIF_XML) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(MetadataFrameType::ONVIF_XML);
  return EnumNamesMetadataFrameType()[index];
}

enum class ObjectDetectorFrameType : uint16_t {
  OBJECT_DETECTOR = 1,
  MIN = OBJECT_DETECTOR,
  MAX = OBJECT_DETECTOR
};

inline const ObjectDetectorFrameType (&EnumValuesObjectDetectorFrameType())[1] {
  static const ObjectDetectorFrameType values[] = {
    ObjectDetectorFrameType::OBJECT_DETECTOR
  };
  return values;
}

inline const char * const *EnumNamesObjectDetectorFrameType() {
  static const char * const names[2] = {
    "OBJECT_DETECTOR",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectDetectorFrameType(ObjectDetectorFrameType e) {
  if (e < ObjectDetectorFrameType::OBJECT_DETECTOR || e > ObjectDetectorFrameType::OBJECT_DETECTOR) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ObjectDetectorFrameType::OBJECT_DETECTOR);
  return EnumNamesObjectDetectorFrameType()[index];
}

struct Codec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_CODEC = 6,
    VT_PARAMETERS = 8
  };
  uint64_t index() const {
    return GetField<uint64_t>(VT_INDEX, 0);
  }
  int32_t codec() const {
    return GetField<int32_t>(VT_CODEC, 0);
  }
  const flatbuffers::String *parameters() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMETERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_CODEC) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyString(parameters()) &&
           verifier.EndTable();
  }
};

struct CodecBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(uint64_t index) {
    fbb_.AddElement<uint64_t>(Codec::VT_INDEX, index, 0);
  }
  void add_codec(int32_t codec) {
    fbb_.AddElement<int32_t>(Codec::VT_CODEC, codec, 0);
  }
  void add_parameters(flatbuffers::Offset<flatbuffers::String> parameters) {
    fbb_.AddOffset(Codec::VT_PARAMETERS, parameters);
  }
  explicit CodecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CodecBuilder &operator=(const CodecBuilder &);
  flatbuffers::Offset<Codec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Codec>(end);
    return o;
  }
};

inline flatbuffers::Offset<Codec> CreateCodec(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t index = 0,
    int32_t codec = 0,
    flatbuffers::Offset<flatbuffers::String> parameters = 0) {
  CodecBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_parameters(parameters);
  builder_.add_codec(codec);
  return builder_.Finish();
}

inline flatbuffers::Offset<Codec> CreateCodecDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t index = 0,
    int32_t codec = 0,
    const char *parameters = nullptr) {
  auto parameters__ = parameters ? _fbb.CreateString(parameters) : 0;
  return file::CreateCodec(
      _fbb,
      index,
      codec,
      parameters__);
}

struct H265Frame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODECINDEX = 4,
    VT_MARKER = 6,
    VT_TIME = 8,
    VT_SIGNATURE = 10,
    VT_DONLFIELD = 12,
    VT_OFFSETS = 14,
    VT_DATA = 16
  };
  uint64_t codecindex() const {
    return GetField<uint64_t>(VT_CODECINDEX, 0);
  }
  bool marker() const {
    return GetField<uint8_t>(VT_MARKER, 0) != 0;
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  const flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  bool donlfield() const {
    return GetField<uint8_t>(VT_DONLFIELD, 0) != 0;
  }
  const flatbuffers::Vector<uint32_t> *offsets() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OFFSETS);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CODECINDEX) &&
           VerifyField<uint8_t>(verifier, VT_MARKER) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           VerifyField<uint8_t>(verifier, VT_DONLFIELD) &&
           VerifyOffset(verifier, VT_OFFSETS) &&
           verifier.VerifyVector(offsets()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct H265FrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_codecindex(uint64_t codecindex) {
    fbb_.AddElement<uint64_t>(H265Frame::VT_CODECINDEX, codecindex, 0);
  }
  void add_marker(bool marker) {
    fbb_.AddElement<uint8_t>(H265Frame::VT_MARKER, static_cast<uint8_t>(marker), 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(H265Frame::VT_TIME, time, 0);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(H265Frame::VT_SIGNATURE, signature);
  }
  void add_donlfield(bool donlfield) {
    fbb_.AddElement<uint8_t>(H265Frame::VT_DONLFIELD, static_cast<uint8_t>(donlfield), 0);
  }
  void add_offsets(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> offsets) {
    fbb_.AddOffset(H265Frame::VT_OFFSETS, offsets);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(H265Frame::VT_DATA, data);
  }
  explicit H265FrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  H265FrameBuilder &operator=(const H265FrameBuilder &);
  flatbuffers::Offset<H265Frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<H265Frame>(end);
    return o;
  }
};

inline flatbuffers::Offset<H265Frame> CreateH265Frame(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t codecindex = 0,
    bool marker = false,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature = 0,
    bool donlfield = false,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> offsets = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  H265FrameBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_codecindex(codecindex);
  builder_.add_data(data);
  builder_.add_offsets(offsets);
  builder_.add_signature(signature);
  builder_.add_donlfield(donlfield);
  builder_.add_marker(marker);
  return builder_.Finish();
}

inline flatbuffers::Offset<H265Frame> CreateH265FrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t codecindex = 0,
    bool marker = false,
    uint64_t time = 0,
    const std::vector<uint8_t> *signature = nullptr,
    bool donlfield = false,
    const std::vector<uint32_t> *offsets = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  auto offsets__ = offsets ? _fbb.CreateVector<uint32_t>(*offsets) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return file::CreateH265Frame(
      _fbb,
      codecindex,
      marker,
      time,
      signature__,
      donlfield,
      offsets__,
      data__);
}

struct H264Frame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODECINDEX = 4,
    VT_MARKER = 6,
    VT_TIME = 8,
    VT_SIGNATURE = 10,
    VT_OFFSETS = 12,
    VT_DATA = 14
  };
  uint64_t codecindex() const {
    return GetField<uint64_t>(VT_CODECINDEX, 0);
  }
  bool marker() const {
    return GetField<uint8_t>(VT_MARKER, 0) != 0;
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  const flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  const flatbuffers::Vector<uint32_t> *offsets() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OFFSETS);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CODECINDEX) &&
           VerifyField<uint8_t>(verifier, VT_MARKER) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           VerifyOffset(verifier, VT_OFFSETS) &&
           verifier.VerifyVector(offsets()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct H264FrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_codecindex(uint64_t codecindex) {
    fbb_.AddElement<uint64_t>(H264Frame::VT_CODECINDEX, codecindex, 0);
  }
  void add_marker(bool marker) {
    fbb_.AddElement<uint8_t>(H264Frame::VT_MARKER, static_cast<uint8_t>(marker), 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(H264Frame::VT_TIME, time, 0);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(H264Frame::VT_SIGNATURE, signature);
  }
  void add_offsets(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> offsets) {
    fbb_.AddOffset(H264Frame::VT_OFFSETS, offsets);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(H264Frame::VT_DATA, data);
  }
  explicit H264FrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  H264FrameBuilder &operator=(const H264FrameBuilder &);
  flatbuffers::Offset<H264Frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<H264Frame>(end);
    return o;
  }
};

inline flatbuffers::Offset<H264Frame> CreateH264Frame(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t codecindex = 0,
    bool marker = false,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> offsets = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  H264FrameBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_codecindex(codecindex);
  builder_.add_data(data);
  builder_.add_offsets(offsets);
  builder_.add_signature(signature);
  builder_.add_marker(marker);
  return builder_.Finish();
}

inline flatbuffers::Offset<H264Frame> CreateH264FrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t codecindex = 0,
    bool marker = false,
    uint64_t time = 0,
    const std::vector<uint8_t> *signature = nullptr,
    const std::vector<uint32_t> *offsets = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  auto offsets__ = offsets ? _fbb.CreateVector<uint32_t>(*offsets) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return file::CreateH264Frame(
      _fbb,
      codecindex,
      marker,
      time,
      signature__,
      offsets__,
      data__);
}

struct JPEGFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODECINDEX = 4,
    VT_TIME = 6,
    VT_SIGNATURE = 8,
    VT_RESTARTINTERVAL = 10,
    VT_TYPESPECIFICFRAGMENTOFFSET = 12,
    VT_TYPE = 14,
    VT_Q = 16,
    VT_WIDTH = 18,
    VT_HEIGHT = 20,
    VT_LQT = 22,
    VT_CQT = 24,
    VT_DATA = 26
  };
  uint64_t codecindex() const {
    return GetField<uint64_t>(VT_CODECINDEX, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  const flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  uint16_t restartinterval() const {
    return GetField<uint16_t>(VT_RESTARTINTERVAL, 0);
  }
  uint32_t typespecificfragmentoffset() const {
    return GetField<uint32_t>(VT_TYPESPECIFICFRAGMENTOFFSET, 0);
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  uint8_t q() const {
    return GetField<uint8_t>(VT_Q, 0);
  }
  uint8_t width() const {
    return GetField<uint8_t>(VT_WIDTH, 0);
  }
  uint8_t height() const {
    return GetField<uint8_t>(VT_HEIGHT, 0);
  }
  const flatbuffers::Vector<uint8_t> *lqt() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_LQT);
  }
  const flatbuffers::Vector<uint8_t> *cqt() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CQT);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CODECINDEX) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           VerifyField<uint16_t>(verifier, VT_RESTARTINTERVAL) &&
           VerifyField<uint32_t>(verifier, VT_TYPESPECIFICFRAGMENTOFFSET) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_Q) &&
           VerifyField<uint8_t>(verifier, VT_WIDTH) &&
           VerifyField<uint8_t>(verifier, VT_HEIGHT) &&
           VerifyOffset(verifier, VT_LQT) &&
           verifier.VerifyVector(lqt()) &&
           VerifyOffset(verifier, VT_CQT) &&
           verifier.VerifyVector(cqt()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct JPEGFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_codecindex(uint64_t codecindex) {
    fbb_.AddElement<uint64_t>(JPEGFrame::VT_CODECINDEX, codecindex, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(JPEGFrame::VT_TIME, time, 0);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(JPEGFrame::VT_SIGNATURE, signature);
  }
  void add_restartinterval(uint16_t restartinterval) {
    fbb_.AddElement<uint16_t>(JPEGFrame::VT_RESTARTINTERVAL, restartinterval, 0);
  }
  void add_typespecificfragmentoffset(uint32_t typespecificfragmentoffset) {
    fbb_.AddElement<uint32_t>(JPEGFrame::VT_TYPESPECIFICFRAGMENTOFFSET, typespecificfragmentoffset, 0);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(JPEGFrame::VT_TYPE, type, 0);
  }
  void add_q(uint8_t q) {
    fbb_.AddElement<uint8_t>(JPEGFrame::VT_Q, q, 0);
  }
  void add_width(uint8_t width) {
    fbb_.AddElement<uint8_t>(JPEGFrame::VT_WIDTH, width, 0);
  }
  void add_height(uint8_t height) {
    fbb_.AddElement<uint8_t>(JPEGFrame::VT_HEIGHT, height, 0);
  }
  void add_lqt(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lqt) {
    fbb_.AddOffset(JPEGFrame::VT_LQT, lqt);
  }
  void add_cqt(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> cqt) {
    fbb_.AddOffset(JPEGFrame::VT_CQT, cqt);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(JPEGFrame::VT_DATA, data);
  }
  explicit JPEGFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  JPEGFrameBuilder &operator=(const JPEGFrameBuilder &);
  flatbuffers::Offset<JPEGFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<JPEGFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<JPEGFrame> CreateJPEGFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t codecindex = 0,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature = 0,
    uint16_t restartinterval = 0,
    uint32_t typespecificfragmentoffset = 0,
    uint8_t type = 0,
    uint8_t q = 0,
    uint8_t width = 0,
    uint8_t height = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> lqt = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> cqt = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  JPEGFrameBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_codecindex(codecindex);
  builder_.add_data(data);
  builder_.add_cqt(cqt);
  builder_.add_lqt(lqt);
  builder_.add_typespecificfragmentoffset(typespecificfragmentoffset);
  builder_.add_signature(signature);
  builder_.add_restartinterval(restartinterval);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_q(q);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<JPEGFrame> CreateJPEGFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t codecindex = 0,
    uint64_t time = 0,
    const std::vector<uint8_t> *signature = nullptr,
    uint16_t restartinterval = 0,
    uint32_t typespecificfragmentoffset = 0,
    uint8_t type = 0,
    uint8_t q = 0,
    uint8_t width = 0,
    uint8_t height = 0,
    const std::vector<uint8_t> *lqt = nullptr,
    const std::vector<uint8_t> *cqt = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  auto lqt__ = lqt ? _fbb.CreateVector<uint8_t>(*lqt) : 0;
  auto cqt__ = cqt ? _fbb.CreateVector<uint8_t>(*cqt) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return file::CreateJPEGFrame(
      _fbb,
      codecindex,
      time,
      signature__,
      restartinterval,
      typespecificfragmentoffset,
      type,
      q,
      width,
      height,
      lqt__,
      cqt__,
      data__);
}

struct MetadataFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODECINDEX = 4,
    VT_TIME = 6,
    VT_SIGNATURE = 8,
    VT_METADATAFRAMETYPE = 10,
    VT_DATA = 12
  };
  uint64_t codecindex() const {
    return GetField<uint64_t>(VT_CODECINDEX, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  const flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  file::MetadataFrameType metadataframetype() const {
    return static_cast<file::MetadataFrameType>(GetField<uint16_t>(VT_METADATAFRAMETYPE, 1));
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CODECINDEX) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           VerifyField<uint16_t>(verifier, VT_METADATAFRAMETYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct MetadataFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_codecindex(uint64_t codecindex) {
    fbb_.AddElement<uint64_t>(MetadataFrame::VT_CODECINDEX, codecindex, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(MetadataFrame::VT_TIME, time, 0);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(MetadataFrame::VT_SIGNATURE, signature);
  }
  void add_metadataframetype(file::MetadataFrameType metadataframetype) {
    fbb_.AddElement<uint16_t>(MetadataFrame::VT_METADATAFRAMETYPE, static_cast<uint16_t>(metadataframetype), 1);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(MetadataFrame::VT_DATA, data);
  }
  explicit MetadataFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetadataFrameBuilder &operator=(const MetadataFrameBuilder &);
  flatbuffers::Offset<MetadataFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MetadataFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<MetadataFrame> CreateMetadataFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t codecindex = 0,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature = 0,
    file::MetadataFrameType metadataframetype = file::MetadataFrameType::ONVIF_XML,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  MetadataFrameBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_codecindex(codecindex);
  builder_.add_data(data);
  builder_.add_signature(signature);
  builder_.add_metadataframetype(metadataframetype);
  return builder_.Finish();
}

inline flatbuffers::Offset<MetadataFrame> CreateMetadataFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t codecindex = 0,
    uint64_t time = 0,
    const std::vector<uint8_t> *signature = nullptr,
    file::MetadataFrameType metadataframetype = file::MetadataFrameType::ONVIF_XML,
    const std::vector<uint8_t> *data = nullptr) {
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return file::CreateMetadataFrame(
      _fbb,
      codecindex,
      time,
      signature__,
      metadataframetype,
      data__);
}

struct MPEG4Frame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODECINDEX = 4,
    VT_MARKER = 6,
    VT_TIME = 8,
    VT_SIGNATURE = 10,
    VT_DATA = 12
  };
  uint64_t codecindex() const {
    return GetField<uint64_t>(VT_CODECINDEX, 0);
  }
  bool marker() const {
    return GetField<uint8_t>(VT_MARKER, 0) != 0;
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  const flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CODECINDEX) &&
           VerifyField<uint8_t>(verifier, VT_MARKER) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct MPEG4FrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_codecindex(uint64_t codecindex) {
    fbb_.AddElement<uint64_t>(MPEG4Frame::VT_CODECINDEX, codecindex, 0);
  }
  void add_marker(bool marker) {
    fbb_.AddElement<uint8_t>(MPEG4Frame::VT_MARKER, static_cast<uint8_t>(marker), 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(MPEG4Frame::VT_TIME, time, 0);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(MPEG4Frame::VT_SIGNATURE, signature);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(MPEG4Frame::VT_DATA, data);
  }
  explicit MPEG4FrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MPEG4FrameBuilder &operator=(const MPEG4FrameBuilder &);
  flatbuffers::Offset<MPEG4Frame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MPEG4Frame>(end);
    return o;
  }
};

inline flatbuffers::Offset<MPEG4Frame> CreateMPEG4Frame(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t codecindex = 0,
    bool marker = false,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  MPEG4FrameBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_codecindex(codecindex);
  builder_.add_data(data);
  builder_.add_signature(signature);
  builder_.add_marker(marker);
  return builder_.Finish();
}

inline flatbuffers::Offset<MPEG4Frame> CreateMPEG4FrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t codecindex = 0,
    bool marker = false,
    uint64_t time = 0,
    const std::vector<uint8_t> *signature = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return file::CreateMPEG4Frame(
      _fbb,
      codecindex,
      marker,
      time,
      signature__,
      data__);
}

struct ObjectDetectorFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODECINDEX = 4,
    VT_TIME = 6,
    VT_SIGNATURE = 8,
    VT_OBJECTDETECTORFRAMETYPE = 10,
    VT_DATA = 12
  };
  uint64_t codecindex() const {
    return GetField<uint64_t>(VT_CODECINDEX, 0);
  }
  uint64_t time() const {
    return GetField<uint64_t>(VT_TIME, 0);
  }
  const flatbuffers::Vector<uint8_t> *signature() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIGNATURE);
  }
  file::ObjectDetectorFrameType objectdetectorframetype() const {
    return static_cast<file::ObjectDetectorFrameType>(GetField<uint16_t>(VT_OBJECTDETECTORFRAMETYPE, 1));
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_CODECINDEX) &&
           VerifyField<uint64_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyVector(signature()) &&
           VerifyField<uint16_t>(verifier, VT_OBJECTDETECTORFRAMETYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct ObjectDetectorFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_codecindex(uint64_t codecindex) {
    fbb_.AddElement<uint64_t>(ObjectDetectorFrame::VT_CODECINDEX, codecindex, 0);
  }
  void add_time(uint64_t time) {
    fbb_.AddElement<uint64_t>(ObjectDetectorFrame::VT_TIME, time, 0);
  }
  void add_signature(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature) {
    fbb_.AddOffset(ObjectDetectorFrame::VT_SIGNATURE, signature);
  }
  void add_objectdetectorframetype(file::ObjectDetectorFrameType objectdetectorframetype) {
    fbb_.AddElement<uint16_t>(ObjectDetectorFrame::VT_OBJECTDETECTORFRAMETYPE, static_cast<uint16_t>(objectdetectorframetype), 1);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(ObjectDetectorFrame::VT_DATA, data);
  }
  explicit ObjectDetectorFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectDetectorFrameBuilder &operator=(const ObjectDetectorFrameBuilder &);
  flatbuffers::Offset<ObjectDetectorFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectDetectorFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectDetectorFrame> CreateObjectDetectorFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t codecindex = 0,
    uint64_t time = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> signature = 0,
    file::ObjectDetectorFrameType objectdetectorframetype = file::ObjectDetectorFrameType::OBJECT_DETECTOR,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  ObjectDetectorFrameBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_codecindex(codecindex);
  builder_.add_data(data);
  builder_.add_signature(signature);
  builder_.add_objectdetectorframetype(objectdetectorframetype);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectDetectorFrame> CreateObjectDetectorFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t codecindex = 0,
    uint64_t time = 0,
    const std::vector<uint8_t> *signature = nullptr,
    file::ObjectDetectorFrameType objectdetectorframetype = file::ObjectDetectorFrameType::OBJECT_DETECTOR,
    const std::vector<uint8_t> *data = nullptr) {
  auto signature__ = signature ? _fbb.CreateVector<uint8_t>(*signature) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return file::CreateObjectDetectorFrame(
      _fbb,
      codecindex,
      time,
      signature__,
      objectdetectorframetype,
      data__);
}

struct FrameHeader FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4,
    VT_SIZE = 6
  };
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  uint64_t size() const {
    return GetField<uint64_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET) &&
           VerifyField<uint64_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct FrameHeaderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(FrameHeader::VT_OFFSET, offset, 0);
  }
  void add_size(uint64_t size) {
    fbb_.AddElement<uint64_t>(FrameHeader::VT_SIZE, size, 0);
  }
  explicit FrameHeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FrameHeaderBuilder &operator=(const FrameHeaderBuilder &);
  flatbuffers::Offset<FrameHeader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FrameHeader>(end);
    return o;
  }
};

inline flatbuffers::Offset<FrameHeader> CreateFrameHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t offset = 0,
    uint64_t size = 0) {
  FrameHeaderBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_offset(offset);
  return builder_.Finish();
}

struct Track FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_DESCRIPTION = 6,
    VT_CODECS = 8,
    VT_H265FRAMEHEADERS = 10,
    VT_H264FRAMEHEADERS = 12,
    VT_JPEGFRAMEHEADERS = 14,
    VT_METADATAFRAMEHEADERS = 16,
    VT_MPEG4FRAMEHEADERS = 18,
    VT_OBJECTDETECTORFRAMEHEADERS = 20
  };
  uint64_t index() const {
    return GetField<uint64_t>(VT_INDEX, 0);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<file::Codec>> *codecs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<file::Codec>> *>(VT_CODECS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>> *h265frameheaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>> *>(VT_H265FRAMEHEADERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>> *h264frameheaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>> *>(VT_H264FRAMEHEADERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>> *jpegframeheaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>> *>(VT_JPEGFRAMEHEADERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>> *metadataframeheaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>> *>(VT_METADATAFRAMEHEADERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>> *mpeg4frameheaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>> *>(VT_MPEG4FRAMEHEADERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>> *objectdetectorframeheaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>> *>(VT_OBJECTDETECTORFRAMEHEADERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_CODECS) &&
           verifier.VerifyVector(codecs()) &&
           verifier.VerifyVectorOfTables(codecs()) &&
           VerifyOffset(verifier, VT_H265FRAMEHEADERS) &&
           verifier.VerifyVector(h265frameheaders()) &&
           verifier.VerifyVectorOfTables(h265frameheaders()) &&
           VerifyOffset(verifier, VT_H264FRAMEHEADERS) &&
           verifier.VerifyVector(h264frameheaders()) &&
           verifier.VerifyVectorOfTables(h264frameheaders()) &&
           VerifyOffset(verifier, VT_JPEGFRAMEHEADERS) &&
           verifier.VerifyVector(jpegframeheaders()) &&
           verifier.VerifyVectorOfTables(jpegframeheaders()) &&
           VerifyOffset(verifier, VT_METADATAFRAMEHEADERS) &&
           verifier.VerifyVector(metadataframeheaders()) &&
           verifier.VerifyVectorOfTables(metadataframeheaders()) &&
           VerifyOffset(verifier, VT_MPEG4FRAMEHEADERS) &&
           verifier.VerifyVector(mpeg4frameheaders()) &&
           verifier.VerifyVectorOfTables(mpeg4frameheaders()) &&
           VerifyOffset(verifier, VT_OBJECTDETECTORFRAMEHEADERS) &&
           verifier.VerifyVector(objectdetectorframeheaders()) &&
           verifier.VerifyVectorOfTables(objectdetectorframeheaders()) &&
           verifier.EndTable();
  }
};

struct TrackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(uint64_t index) {
    fbb_.AddElement<uint64_t>(Track::VT_INDEX, index, 0);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Track::VT_DESCRIPTION, description);
  }
  void add_codecs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Codec>>> codecs) {
    fbb_.AddOffset(Track::VT_CODECS, codecs);
  }
  void add_h265frameheaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>>> h265frameheaders) {
    fbb_.AddOffset(Track::VT_H265FRAMEHEADERS, h265frameheaders);
  }
  void add_h264frameheaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>>> h264frameheaders) {
    fbb_.AddOffset(Track::VT_H264FRAMEHEADERS, h264frameheaders);
  }
  void add_jpegframeheaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>>> jpegframeheaders) {
    fbb_.AddOffset(Track::VT_JPEGFRAMEHEADERS, jpegframeheaders);
  }
  void add_metadataframeheaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>>> metadataframeheaders) {
    fbb_.AddOffset(Track::VT_METADATAFRAMEHEADERS, metadataframeheaders);
  }
  void add_mpeg4frameheaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>>> mpeg4frameheaders) {
    fbb_.AddOffset(Track::VT_MPEG4FRAMEHEADERS, mpeg4frameheaders);
  }
  void add_objectdetectorframeheaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>>> objectdetectorframeheaders) {
    fbb_.AddOffset(Track::VT_OBJECTDETECTORFRAMEHEADERS, objectdetectorframeheaders);
  }
  explicit TrackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TrackBuilder &operator=(const TrackBuilder &);
  flatbuffers::Offset<Track> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Track>(end);
    return o;
  }
};

inline flatbuffers::Offset<Track> CreateTrack(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t index = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Codec>>> codecs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>>> h265frameheaders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>>> h264frameheaders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>>> jpegframeheaders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>>> metadataframeheaders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>>> mpeg4frameheaders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::FrameHeader>>> objectdetectorframeheaders = 0) {
  TrackBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_objectdetectorframeheaders(objectdetectorframeheaders);
  builder_.add_mpeg4frameheaders(mpeg4frameheaders);
  builder_.add_metadataframeheaders(metadataframeheaders);
  builder_.add_jpegframeheaders(jpegframeheaders);
  builder_.add_h264frameheaders(h264frameheaders);
  builder_.add_h265frameheaders(h265frameheaders);
  builder_.add_codecs(codecs);
  builder_.add_description(description);
  return builder_.Finish();
}

inline flatbuffers::Offset<Track> CreateTrackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t index = 0,
    const char *description = nullptr,
    const std::vector<flatbuffers::Offset<file::Codec>> *codecs = nullptr,
    const std::vector<flatbuffers::Offset<file::FrameHeader>> *h265frameheaders = nullptr,
    const std::vector<flatbuffers::Offset<file::FrameHeader>> *h264frameheaders = nullptr,
    const std::vector<flatbuffers::Offset<file::FrameHeader>> *jpegframeheaders = nullptr,
    const std::vector<flatbuffers::Offset<file::FrameHeader>> *metadataframeheaders = nullptr,
    const std::vector<flatbuffers::Offset<file::FrameHeader>> *mpeg4frameheaders = nullptr,
    const std::vector<flatbuffers::Offset<file::FrameHeader>> *objectdetectorframeheaders = nullptr) {
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto codecs__ = codecs ? _fbb.CreateVector<flatbuffers::Offset<file::Codec>>(*codecs) : 0;
  auto h265frameheaders__ = h265frameheaders ? _fbb.CreateVector<flatbuffers::Offset<file::FrameHeader>>(*h265frameheaders) : 0;
  auto h264frameheaders__ = h264frameheaders ? _fbb.CreateVector<flatbuffers::Offset<file::FrameHeader>>(*h264frameheaders) : 0;
  auto jpegframeheaders__ = jpegframeheaders ? _fbb.CreateVector<flatbuffers::Offset<file::FrameHeader>>(*jpegframeheaders) : 0;
  auto metadataframeheaders__ = metadataframeheaders ? _fbb.CreateVector<flatbuffers::Offset<file::FrameHeader>>(*metadataframeheaders) : 0;
  auto mpeg4frameheaders__ = mpeg4frameheaders ? _fbb.CreateVector<flatbuffers::Offset<file::FrameHeader>>(*mpeg4frameheaders) : 0;
  auto objectdetectorframeheaders__ = objectdetectorframeheaders ? _fbb.CreateVector<flatbuffers::Offset<file::FrameHeader>>(*objectdetectorframeheaders) : 0;
  return file::CreateTrack(
      _fbb,
      index,
      description__,
      codecs__,
      h265frameheaders__,
      h264frameheaders__,
      jpegframeheaders__,
      metadataframeheaders__,
      mpeg4frameheaders__,
      objectdetectorframeheaders__);
}

struct Recording FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_NAME = 6,
    VT_LOCATION = 8,
    VT_VIDEOTRACKS = 10,
    VT_AUDIOTRACKS = 12,
    VT_METADATATRACKS = 14,
    VT_OBJECTDETECTORTRACKS = 16
  };
  uint64_t index() const {
    return GetField<uint64_t>(VT_INDEX, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *location() const {
    return GetPointer<const flatbuffers::String *>(VT_LOCATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<file::Track>> *videotracks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<file::Track>> *>(VT_VIDEOTRACKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<file::Track>> *audiotracks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<file::Track>> *>(VT_AUDIOTRACKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<file::Track>> *metadatatracks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<file::Track>> *>(VT_METADATATRACKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<file::Track>> *objectdetectortracks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<file::Track>> *>(VT_OBJECTDETECTORTRACKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyString(location()) &&
           VerifyOffset(verifier, VT_VIDEOTRACKS) &&
           verifier.VerifyVector(videotracks()) &&
           verifier.VerifyVectorOfTables(videotracks()) &&
           VerifyOffset(verifier, VT_AUDIOTRACKS) &&
           verifier.VerifyVector(audiotracks()) &&
           verifier.VerifyVectorOfTables(audiotracks()) &&
           VerifyOffset(verifier, VT_METADATATRACKS) &&
           verifier.VerifyVector(metadatatracks()) &&
           verifier.VerifyVectorOfTables(metadatatracks()) &&
           VerifyOffset(verifier, VT_OBJECTDETECTORTRACKS) &&
           verifier.VerifyVector(objectdetectortracks()) &&
           verifier.VerifyVectorOfTables(objectdetectortracks()) &&
           verifier.EndTable();
  }
};

struct RecordingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(uint64_t index) {
    fbb_.AddElement<uint64_t>(Recording::VT_INDEX, index, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Recording::VT_NAME, name);
  }
  void add_location(flatbuffers::Offset<flatbuffers::String> location) {
    fbb_.AddOffset(Recording::VT_LOCATION, location);
  }
  void add_videotracks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Track>>> videotracks) {
    fbb_.AddOffset(Recording::VT_VIDEOTRACKS, videotracks);
  }
  void add_audiotracks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Track>>> audiotracks) {
    fbb_.AddOffset(Recording::VT_AUDIOTRACKS, audiotracks);
  }
  void add_metadatatracks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Track>>> metadatatracks) {
    fbb_.AddOffset(Recording::VT_METADATATRACKS, metadatatracks);
  }
  void add_objectdetectortracks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Track>>> objectdetectortracks) {
    fbb_.AddOffset(Recording::VT_OBJECTDETECTORTRACKS, objectdetectortracks);
  }
  explicit RecordingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RecordingBuilder &operator=(const RecordingBuilder &);
  flatbuffers::Offset<Recording> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Recording>(end);
    return o;
  }
};

inline flatbuffers::Offset<Recording> CreateRecording(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t index = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> location = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Track>>> videotracks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Track>>> audiotracks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Track>>> metadatatracks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Track>>> objectdetectortracks = 0) {
  RecordingBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_objectdetectortracks(objectdetectortracks);
  builder_.add_metadatatracks(metadatatracks);
  builder_.add_audiotracks(audiotracks);
  builder_.add_videotracks(videotracks);
  builder_.add_location(location);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Recording> CreateRecordingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t index = 0,
    const char *name = nullptr,
    const char *location = nullptr,
    const std::vector<flatbuffers::Offset<file::Track>> *videotracks = nullptr,
    const std::vector<flatbuffers::Offset<file::Track>> *audiotracks = nullptr,
    const std::vector<flatbuffers::Offset<file::Track>> *metadatatracks = nullptr,
    const std::vector<flatbuffers::Offset<file::Track>> *objectdetectortracks = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto location__ = location ? _fbb.CreateString(location) : 0;
  auto videotracks__ = videotracks ? _fbb.CreateVector<flatbuffers::Offset<file::Track>>(*videotracks) : 0;
  auto audiotracks__ = audiotracks ? _fbb.CreateVector<flatbuffers::Offset<file::Track>>(*audiotracks) : 0;
  auto metadatatracks__ = metadatatracks ? _fbb.CreateVector<flatbuffers::Offset<file::Track>>(*metadatatracks) : 0;
  auto objectdetectortracks__ = objectdetectortracks ? _fbb.CreateVector<flatbuffers::Offset<file::Track>>(*objectdetectortracks) : 0;
  return file::CreateRecording(
      _fbb,
      index,
      name__,
      location__,
      videotracks__,
      audiotracks__,
      metadatatracks__,
      objectdetectortracks__);
}

struct Device FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_NAME = 6,
    VT_ADDRESS = 8,
    VT_SIGNINGKEY = 10,
    VT_RECORDINGS = 12
  };
  uint64_t index() const {
    return GetField<uint64_t>(VT_INDEX, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  const flatbuffers::String *signingkey() const {
    return GetPointer<const flatbuffers::String *>(VT_SIGNINGKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<file::Recording>> *recordings() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<file::Recording>> *>(VT_RECORDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_INDEX) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyString(address()) &&
           VerifyOffset(verifier, VT_SIGNINGKEY) &&
           verifier.VerifyString(signingkey()) &&
           VerifyOffset(verifier, VT_RECORDINGS) &&
           verifier.VerifyVector(recordings()) &&
           verifier.VerifyVectorOfTables(recordings()) &&
           verifier.EndTable();
  }
};

struct DeviceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(uint64_t index) {
    fbb_.AddElement<uint64_t>(Device::VT_INDEX, index, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Device::VT_NAME, name);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Device::VT_ADDRESS, address);
  }
  void add_signingkey(flatbuffers::Offset<flatbuffers::String> signingkey) {
    fbb_.AddOffset(Device::VT_SIGNINGKEY, signingkey);
  }
  void add_recordings(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Recording>>> recordings) {
    fbb_.AddOffset(Device::VT_RECORDINGS, recordings);
  }
  explicit DeviceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeviceBuilder &operator=(const DeviceBuilder &);
  flatbuffers::Offset<Device> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Device>(end);
    return o;
  }
};

inline flatbuffers::Offset<Device> CreateDevice(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t index = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    flatbuffers::Offset<flatbuffers::String> signingkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Recording>>> recordings = 0) {
  DeviceBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_recordings(recordings);
  builder_.add_signingkey(signingkey);
  builder_.add_address(address);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Device> CreateDeviceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t index = 0,
    const char *name = nullptr,
    const char *address = nullptr,
    const char *signingkey = nullptr,
    const std::vector<flatbuffers::Offset<file::Recording>> *recordings = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto address__ = address ? _fbb.CreateString(address) : 0;
  auto signingkey__ = signingkey ? _fbb.CreateString(signingkey) : 0;
  auto recordings__ = recordings ? _fbb.CreateVector<flatbuffers::Offset<file::Recording>>(*recordings) : 0;
  return file::CreateDevice(
      _fbb,
      index,
      name__,
      address__,
      signingkey__,
      recordings__);
}

struct File FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEVICES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<file::Device>> *devices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<file::Device>> *>(VT_DEVICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEVICES) &&
           verifier.VerifyVector(devices()) &&
           verifier.VerifyVectorOfTables(devices()) &&
           verifier.EndTable();
  }
};

struct FileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_devices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Device>>> devices) {
    fbb_.AddOffset(File::VT_DEVICES, devices);
  }
  explicit FileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileBuilder &operator=(const FileBuilder &);
  flatbuffers::Offset<File> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<File>(end);
    return o;
  }
};

inline flatbuffers::Offset<File> CreateFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<file::Device>>> devices = 0) {
  FileBuilder builder_(_fbb);
  builder_.add_devices(devices);
  return builder_.Finish();
}

inline flatbuffers::Offset<File> CreateFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<file::Device>> *devices = nullptr) {
  auto devices__ = devices ? _fbb.CreateVector<flatbuffers::Offset<file::Device>>(*devices) : 0;
  return file::CreateFile(
      _fbb,
      devices__);
}

inline const file::File *GetFile(const void *buf) {
  return flatbuffers::GetRoot<file::File>(buf);
}

inline const file::File *GetSizePrefixedFile(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<file::File>(buf);
}

inline bool VerifyFileBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<file::File>(nullptr);
}

inline bool VerifySizePrefixedFileBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<file::File>(nullptr);
}

inline void FinishFileBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<file::File> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFileBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<file::File> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace file

#endif  // FLATBUFFERS_GENERATED_FILE_FILE_H_
